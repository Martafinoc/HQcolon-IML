import SimpleITK as sitk
import numpy as np
import os
import vtk
import re
from skimage import measure

from scipy.ndimage import binary_erosion
from scipy.spatial import KDTree
import matplotlib.pyplot as plt
import napari

import SimpleITK as sitk
import numpy as np
import scipy.ndimage as ndimage
from scipy.ndimage import gaussian_filter
from scipy.ndimage import binary_closing

"""
This pipeline allows to post-process the fluid segmntation generated by rootpainter trained model
Input: fluid .mha segmentation file and the corresponding colon air-filled segmentation .mha file
"""

def reorient_array_with_matrix_M(image_array, direction, origin):
    """
    Reorient a 3D NumPy array (z, y, x) using a 3x3 transformation matrix.
    This approach does a nearest-neighbor remapping without interpolation.
    This is to orient all the colon in the same direction (i.e., RAI), considering their directioanl matrix.

    Parameters
    ----------
    array_lps : np.ndarray
        3D array with shape (z, y, x).
    transform_matrix : np.ndarray
        A 3x3 transform matrix (float or int).

    Returns
    -------
    array_transformed : np.ndarray
        A new 3D array of the same shape, where each voxel has been mapped
        to its new location. Voxels mapped outside the array are discarded.
    """
    # Transpose the NumPy array to match the ITK shape (x, y, z)
    T_image_array = np.transpose(image_array, (2, 1, 0))
    x_size, y_size, z_size = T_image_array.shape
    T_image_array_RAI = np.zeros_like(T_image_array)


    # Create a grid of all (z, y, x) coordinates: shape (3, z*y*x)
    coords = np.mgrid[0:x_size, 0:y_size, 0:z_size]
    coords = coords.reshape(3, -1).astype(np.float32)  # float for matrix multiplication
    coords = coords.T

    direction_matrix = np.array(direction).reshape(3, 3)  # Reshape direction to 3x3 matrix
    new_coords = np.dot(coords, direction_matrix.T)  # Rotate vertices

    # Round to nearest integer indices
    new_coords = np.rint(new_coords).astype(np.int32)

    # Get valid source indices (old) and destination indices (new)
    old_x = coords[:,0].astype(np.int32)
    old_y = coords[:,1].astype(np.int32)
    old_z = coords[:,2].astype(np.int32)

    new_x = new_coords[:,0]
    new_y = new_coords[:,1]
    new_z = new_coords[:,2]

    # Vectorized assignment: last write wins if collisions occur
    T_image_array_RAI[new_x, new_y, new_z] = T_image_array[old_x, old_y, old_z]

    return T_image_array_RAI

def revert_reorientation(image_array, direction):
    """
    Reverse the transformation applied by `reorient_array_with_matrix_M`
    to restore the array to its original reference system.

    Parameters:
    ----------
    image_array : np.ndarray
        3D array (z, y, x) in the transformed coordinate system.
    direction : list or tuple
        Flattened 3x3 transformation matrix (row-major order).
    origin : tuple
        (ox, oy, oz) translation.

    Returns:
    -------
    original_array : np.ndarray
        The array restored to its original reference system.
    """

    # Transpose back from ITK format (x, y, z) to (z, y, x)
    #T_image_array = np.transpose(image_array, (2, 1, 0))
    x_size, y_size, z_size = image_array.shape
    restored_array = np.zeros_like(image_array)

    # Generate grid of all voxel indices in the transformed space
    coords = np.mgrid[0:x_size, 0:y_size, 0:z_size]
    coords = coords.reshape(3, -1).astype(np.float32).T  # Shape: (num_voxels, 3)

    # Convert the direction matrix back to a 3Ã—3 matrix
    direction_matrix = np.array(direction).reshape(3, 3)

    # Compute the inverse of the direction matrix (to undo the transformation)
    inv_direction_matrix = np.linalg.inv(direction_matrix)

    # Apply inverse rotation to get original voxel indices
    original_coords = np.dot(coords, inv_direction_matrix.T)

    # Round to nearest integer indices
    original_coords = np.rint(original_coords).astype(np.int32)

    # Get valid indices
    old_x = coords[:, 0].astype(np.int32)  # Ensure integer type
    old_y = coords[:, 1].astype(np.int32)  # Ensure integer type
    old_z = coords[:, 2].astype(np.int32)  # Ensure integer type

    new_x = original_coords[:, 0]
    new_y = original_coords[:, 1]
    new_z = original_coords[:, 2]
    # Ensure indices are within valid array bounds

    # Vectorized assignment: last write wins if collisions occur
    restored_array[new_x, new_y, new_z] = image_array[old_x, old_y, old_z]

    restored_array = np.transpose(restored_array, (2, 1, 0)) #z,y,x

    return restored_array

def get_colon_surface_mask(colon_array):
    #1) Erosion: shrinks the foreground region (the colon) by removing one layer of pixels from the boundary.
    #2) Finds the surface of the colon by taking the difference between the original array and the eroded array.
    #3) Returns a binary mask (surface_mask) that indicates the surface voxels of the colon.
    eroded = binary_erosion(colon_array, structure=np.ones((3, 3, 3))) #Erodes the binary array using a 3D cubic structuring element 3x3x3
    surface_mask = (colon_array == 1) & (eroded == 0)
    return surface_mask

def build_colon_surface_kdtree(colon_surface_mask):
    # 1) finds the indices of all non-zero (True) elements in the colon_surface_mask(N, 3)
    # 2) Constructs a KD-tree rom the surface voxel coordinates (data structure optimized for fast spatial queries, such as finding the nearest neighbors.)
    surface_indices = np.argwhere(colon_surface_mask)  #X,Y,Z of the colon surface voxels, stored in a 2D array of shape (N, 3), where N is numebr of voxels
    tree = KDTree(surface_indices)
    return tree, surface_indices



def clean_fluid_segmentation(colon_mha_path, fluid_mha_path):
    """    
    Load the colon (air-filled segment) and fluid .mha file, clean the fluid and return the labelmap numpy array of the fluid 
    (already transposed to account for the different reference system between numpy and ITK)
    """

    # Load the colon and fluid binary masks
    colon_image = sitk.ReadImage(colon_mha_path) #(x,y,z)
    fluid_image = sitk.ReadImage(fluid_mha_path) #(x,y,z)

    # Get numpy arrays from the images
    colon_array = sitk.GetArrayFromImage(colon_image) #(z,y,x)
    fluid_array = sitk.GetArrayFromImage(fluid_image) #(z,y,x) 

    # Get metadata
    spacing = colon_image.GetSpacing()  # Voxel spacing
    origin = colon_image.GetOrigin()  # Image origin
    direction = colon_image.GetDirection()  # Direction cosine matrix

    metadata = {
        "spacing": spacing,
        "origin": origin,
        "direction": direction,
    }

    # Ensure both masks have the same dimensions
    if colon_array.shape != fluid_array.shape:
        raise ValueError("Colon and fluid masks must have the same dimensions.")

    # Rotate numpy array image according to direction matrix to be have RAI orientation
    colon_array_RAI = reorient_array_with_matrix_M(colon_array, direction, origin)
    fluid_array_RAI = reorient_array_with_matrix_M(fluid_array, direction, origin)

    print('Arrays rotated')

    # # Visualize with Napari
    # viewer = napari.Viewer()
    # #viewer = napari.view_image(colon_array, colormap='gray', name='ITK Image')
    # viewer.add_image(colon_array_RAI, name="Colon", colormap="red", blending="additive")
    # viewer.add_image(colon_array, name="Old Colon", colormap="grey", blending="additive")
    # viewer.add_image(fluid_array_RAI, name="Old Colon", colormap="grey", blending="additive")
    # napari.run()

    # Get numpy arrays from the images
    # colon_array = sitk.GetArrayFromImage(colon_image).astype(bool) #boolean array, 1=foreground, 0=background
    # fluid_array = sitk.GetArrayFromImage(fluid_image).astype(bool) 
    

    # 1) Create a distance map for the colon - 
    # X,Y,Z image with the same shape of the original one (0 in the borders, -distance inside the colon, +distance outside colon)
    colon_distance_map = sitk.SignedMaurerDistanceMap(
        sitk.GetImageFromArray(colon_array_RAI.astype(np.uint8)),
        insideIsPositive=False,
        useImageSpacing=True
    ) 

    # Convert distance map to numpy array
    colon_distance_array = sitk.GetArrayFromImage(colon_distance_map) #not oriented

    # 2) Label connected components in the fluid pockets
    # X,Y,Z image with the same shape of the original one (each voxel of the same connceted component has the same label, i.e., number)
    fluid_cc = sitk.ConnectedComponent(sitk.GetImageFromArray(fluid_array_RAI.astype(np.uint8)))
    fluid_cc_array = sitk.GetArrayFromImage(fluid_cc)
    labels = np.unique(fluid_cc_array) 
    labels = labels[labels != 0]  # Gets all the labels removing the background

    # 3) Create a mask for fluid pockets that are within 2mm of the colon
    #Outout = new_fluid_array - array of the same size of the fluid, with voxels=1 where there is the fluid cleaned
    distance_threshold = 2.0  # Distance in mm
    min_voxel_threshold = 2000  # Minimum number of voxels for a component
    new_fluid_array = np.zeros_like(fluid_array_RAI, dtype=np.uint8)

    for label in labels:
        component_mask = (fluid_cc_array == label)
        component_size = np.sum(component_mask)

        # Distances for this component
        component_distances = colon_distance_array[component_mask]
        min_distance = np.min(component_distances)

        if component_size >= min_voxel_threshold and min_distance <= distance_threshold:
            new_fluid_array[component_mask] = 1

    print('Fluid clenaed - 1st time')

    # 4) For each fluid component in the new_fluid_array, find closest colon surface voxel
    fluid_cc_clean = sitk.ConnectedComponent(sitk.GetImageFromArray(new_fluid_array)) #Label connected components in the new cleaned fluid pockets
    fluid_cc_clean_array = sitk.GetArrayFromImage(fluid_cc_clean)

    # 5) Build the colon surface mask and KD-tree
    colon_surface_mask = get_colon_surface_mask(colon_array_RAI.astype(bool) ) #Binary mask that indicates the surface voxels of the colon.
    surface_tree, surface_indices = build_colon_surface_kdtree(colon_surface_mask) #Create a KD-tree for the surface voxels and get their coordinates.


    final_labels = np.unique(fluid_cc_clean_array)
    final_labels = final_labels[final_labels != 0] #Get the final labels, without the background

    colon_voxel_points = []  # To store all colon voxels (RAI coordinates)
    fluid_voxel_points = []  # To store all fluid voxels (RAI coordinates)


    new_fluid_array_2 = np.zeros_like(new_fluid_array, dtype=np.uint8)
    new_fluid_array_holes = np.zeros_like(new_fluid_array, dtype=np.uint8)
    new_fluid_array_smooth = np.zeros_like(new_fluid_array, dtype=np.uint8)
    new_fluid_array_2_checked = np.zeros_like(new_fluid_array, dtype=np.uint8)
    fluid_attached_to_colon = np.zeros_like(new_fluid_array, dtype=np.uint8)
    voxel_checked = np.zeros_like(new_fluid_array, dtype=np.uint8)

    for label in final_labels:
        comp_mask = (fluid_cc_clean_array == label) #create a mask of the component
        comp_indices = np.argwhere(comp_mask)  # get the indices of the component - (M, 3) fluid voxels, where M is the number of voxels in the fluid pocket
    
        # Reuse the 'colon_distance_array' to find the fluid voxel with the min distance
        comp_distances = colon_distance_array[comp_mask] #1D array of lenght M, where each value corresponds to the distance of a voxel in the current component to the closest colon surface.
        
        # Filter out negative distances
        comp_distances = comp_distances[comp_distances > 0]
        
        if comp_distances.size > 0:
            min_distance = np.min(comp_distances)  # Find the smallest distance value

        # Get all indices where the distance equals the minimum distance
        min_indices = np.where(comp_distances == min_distance)[0]  # Indices of voxels with the smallest distance
        
        # Retrieve the coordinates of all voxels with the smallest distance
        fluid_voxels = comp_indices[min_indices]  # (K, 3), where K is the number of closest voxels

        # Find the centroid of these voxels
        centroid = np.mean(fluid_voxels, axis=0)  # Average of (Z, Y, X) coordinates

        # Find the voxel closest to the centroid
        distances_to_centroid = np.linalg.norm(fluid_voxels - centroid, axis=1)
        central_voxel_index = np.argmin(distances_to_centroid)
        fluid_voxel = fluid_voxels[central_voxel_index]  # (Z, Y, X)


        # 8a. Use the KD-tree to find the nearest colon surface voxel
        dist, nearest_idx = surface_tree.query(fluid_voxel)  # nearest_idx is index in surface_indices
        colon_voxel = surface_indices[nearest_idx]           # (Z, Y, X) of colon surface

        # Append to the arrays
        colon_voxel_points.append(colon_voxel)
        fluid_voxel_points.append(fluid_voxel)

        # 8b. Compare their X-coordinates
        fluid_y = fluid_voxel[1] 
        colon_y = colon_voxel[1]

        if fluid_y < colon_y:
            position_str = "behind"
            
        elif fluid_y > colon_y:
            position_str = "in front of"

        else: position_str = "same as"

        print(f"Fluid Component {label} is {position_str} the colon in the sagittal plane.")

        #Get the border of the component mask
        comp_mask_updated = comp_mask.copy()
        border_fluid_colon_mask = np.zeros_like(comp_mask, dtype=np.uint8)

        eroded_mask = binary_erosion(comp_mask_updated, structure=np.ones((3,3,3)))
        component_border = comp_mask & ~eroded_mask #mask of the size x-y-z (original array_image) 
        border_indices = np.argwhere(component_border) # get the indices of the component border - (M, 3) fluid border voxels
        
        #Get extremities of the fluid component
        y_min, y_max = border_indices[:,1].min(), border_indices[:,1].max()

        erosion = 0
    
        if fluid_y > colon_y:
            for y in range(y_min, y_max + 1): #we check per slice
                first_time =1
                while erosion or first_time: 
                    first_time = 0
                    if erosion:
                        erosion = 0
                        eroded_mask = binary_erosion(comp_mask_updated, structure=np.ones((3,3,3)))
                        component_border = comp_mask_updated & ~eroded_mask #mask of the size x-y-z (original array_image)
                        component_border[border_fluid_colon_mask == 1] = 0  
                        border_indices = np.argwhere(component_border) # get the indices of the component border - (M, 3) fluid border voxels
                    
                    filtered_indices = border_indices[border_indices[:, 1] == y]
                    for x,z in filtered_indices[:, [0, 2]]:
                        if comp_mask_updated[x,y-1,z] == 0: 
                            new_fluid_array_2_checked[x,y,z] = 1
                            #if colon_array_RAI[x-1:x+1, y-2:y, z-1:z+1].sum() == 0:
                            count_ones = np.count_nonzero(colon_array_RAI[x-2:x+2, y-3:y, z-2:z+2] == 1)
                            voxel_checked[x-2:x+2, y-3:y, z-2:z+2] = 1
                            if count_ones == 0:
                                comp_mask_updated[x,y,z]= 0
                                erosion =1
                            else: border_fluid_colon_mask[x,y,z]= 1

        else: 
             for y in range(y_max, y_min -1, - 1): #we check per slice
                first_time =1
                while erosion or first_time: 
                    first_time = 0
                    if erosion:
                        erosion = 0
                        eroded_mask = binary_erosion(comp_mask_updated, structure=np.ones((3,3,3)))
                        component_border = comp_mask_updated & ~eroded_mask #mask of the size x-y-z (original array_image)            
                        component_border[border_fluid_colon_mask == 1] = 0  
                        border_indices = np.argwhere(component_border) # get the indices of the component border - (M, 3) fluid border voxels
                    
                    filtered_indices = border_indices[border_indices[:, 1] == y]
                    for x,z in filtered_indices[:, [0, 2]]:
                        if comp_mask_updated[x,y+1,z] == 0: 
                            new_fluid_array_2_checked[x,y,z] = 1
                            #if colon_array_RAI[x-1:x+1, y-2:y, z-1:z+1].sum() == 0:
                            count_ones = np.count_nonzero(colon_array_RAI[x-2:x+2, y+1:y+4, z-2:z+2] == 1)
                            voxel_checked[x-2:x+2, y+1:y+4, z-2:z+2] = 1
                            if count_ones == 0:
                                comp_mask_updated[x,y,z]= 0
                                erosion =1
                            else: border_fluid_colon_mask[x,y,z]= 1
        
        #Fill the holes in the x-z plane (2D)
        for y in range(comp_mask_updated.shape[1]):  # Loop through Y-dimension
            #comp_mask_updated[:, y, :] = binary_closing(comp_mask_updated[:, y, :], structure=np.ones((3,3)))

            slice_xz = comp_mask_updated[:, y, :]  # Extract the X-Z plane at Y

            # Identify holes (inverted mask)
            holes_mask = ~slice_xz

            # Label connected components in the holes
            labels, num_features = ndimage.label(holes_mask)

            if num_features > 0:
                # Find the largest connected component (likely external background)
                sizes = np.bincount(labels.ravel())
                largest_label = sizes[1:].argmax() + 1  # Ignore background (label 0)

                # Fill all regions except the largest (external air remains untouched)
                filled_holes = (labels != largest_label)

                # Merge the filled holes into the current X-Z slice
                slice_xz = slice_xz | filled_holes

            # Store the updated slice back
            comp_mask_updated[:, y, :] = slice_xz

        
        #Fill thje holes in 3d
        # Invert the mask to detect holes (0s inside 1s)
        holes_mask = ~comp_mask_updated 
        # Label connected components in the inverted mask
        labels_new, num_features = ndimage.label(holes_mask)

        # Find the largest connected component (which is likely the external background)
        sizes = np.bincount(labels_new.ravel())
        largest_label = sizes[1:].argmax() + 1  # Ignore background (label 0)

        # Fill all regions except the largest (external air)
        filled_holes = (labels_new != largest_label)

        # Merge back into the original component
        comp_mask_updated = comp_mask_updated | filled_holes


        new_fluid_array_holes = np.where(comp_mask_updated == 1, comp_mask_updated, new_fluid_array_holes)

        #Smoothing
        # Apply Gaussian smoothing
        smoothed_mask = gaussian_filter(comp_mask_updated.astype(float), sigma=1.0)  # Adjust sigma for more/less smoothing

        # Convert back to binary (thresholding)
        smoothed_mask = smoothed_mask > 0.5  # Choose a threshold that keeps component shape

        # Update the final array
        new_fluid_array_smooth = np.where(smoothed_mask == 1, smoothed_mask, new_fluid_array_smooth)

        #new_fluid_array_2 = np.where(comp_mask_updated == 1, comp_mask_updated, new_fluid_array_2)


        #Connect the fluid to the colon
        smoothed_mask_attach_to_colon=smoothed_mask.copy()
        eroded_mask = binary_erosion(smoothed_mask, structure=np.ones((3,3,3)))
        component_border = smoothed_mask & ~eroded_mask #mask of the size x-y-z (original array_image)
        border_indices_updated = np.argwhere(component_border) # get the indices of the component border - (M, 3) fluid border voxels
        
        if fluid_y > colon_y:
            for y in range(y_min, y_max + 1): #we check per slice
                filtered_indices = border_indices_updated[border_indices_updated[:, 1] == y]
                for x,z in filtered_indices[:, [0, 2]]:
                    if smoothed_mask[x,y-1,z] == 0:
                        where_colon = np.where(colon_array_RAI[x, y-3:y, z] == 1)[0] 
                        if where_colon.size > 0:
                            first_colon_y = (y-3) + where_colon[-1]  # Convert relative index to absolute Y-coordinate
                            smoothed_mask_attach_to_colon[x,first_colon_y:y,z] = 1
        else:
            for y in range(y_max, y_min - 1, - 1): #we check per slice
                filtered_indices = border_indices_updated[border_indices_updated[:, 1] == y]
                for x,z in filtered_indices[:, [0, 2]]:
                    if smoothed_mask[x,y+1,z] == 0:
                        where_colon = np.where(colon_array_RAI[x, y+1:y+4, z] == 1)[0] 
                        if where_colon.size > 0:
                            first_colon_y = y+1 + where_colon[0]  # Convert relative index to absolute Y-coordinate
                            smoothed_mask_attach_to_colon[x,y: first_colon_y,z] = 1
        
        fluid_attached_to_colon = np.where(smoothed_mask_attach_to_colon == 1, smoothed_mask_attach_to_colon, fluid_attached_to_colon)
                
    #Visualize with Napari
    # viewer = napari.Viewer()
    # #viewer = napari.view_image(colon_array, colormap='gray', name='ITK Image')
    # viewer.add_image(colon_array_RAI, name="Colon", colormap="white", blending="additive")
    # viewer.add_image(new_fluid_array, name="New Fluid", colormap="yellow", blending="additive")
    # viewer.add_image(new_fluid_array_2, name="New Fluid 2", colormap="green", blending="additive")
    # viewer.add_image(new_fluid_array_2_checked, name="New Fluid 2 checked", colormap="red", blending="additive")
    # viewer.add_image(voxel_checked, name="Colon", colormap="blue", blending="additive")

    
    # viewer.add_points(
    #     colon_voxel_points,
    #     name="colon voxels",
    #     size=10,              # Point size (increase to make points bigger)
    #     face_color="green",     # Color of the points
    #     edge_color="white",   # Edge color for better visibility
    #     opacity=0.8,          # Transparency
    #     symbol="o"            # Circle-shaped points (default)
    # )
    # viewer.add_points(
    #     fluid_voxel_points,
    #     name="fluid voxels",
    #     size=10,              # Point size (increase to make points bigger)
    #     face_color="blue",     # Color of the points
    #     edge_color="white",   # Edge color for better visibility
    #     opacity=0.8,          # Transparencyrevert_reorientation
    #     symbol="o"            # Circle-shaped points (default)
    # )

    # napari.run()

        
    return new_fluid_array_smooth, fluid_attached_to_colon, metadata



def create_RAI_mesh(labelmap, metadata, output_filename='mesh.vtk'):
    """
    Creates a 3D mesh from a binary labelmap, rotate to match the RAI reference system and save as VTK file.
    
    Parameters:
    - labelmap: 3D numpy array (binary) - already rotated to account for the different reference system between numpy and ITK
    - metadata: spacing (x,y,z),direction (transformation matrix to RAI reference system)
    - output_filename: String, the output file path for the mesh (.vtk format)
    """

    spacing = metadata["spacing"]
    direction = metadata["direction"]
    origin = metadata["origin"]

    # Compute the surface mesh using marching cubes
    verts, faces, _, _ = measure.marching_cubes(labelmap, level=0.5, spacing=spacing)

    # Rotate vertices using the direction matrix to allign with RAI reference system
    direction_matrix = np.array(direction).reshape(3, 3)  # Reshape direction to 3x3 matrix
    verts = np.dot(verts, direction_matrix.T)  # Rotate vertices
    verts += np.array(origin)  # Adjust for origin

    
    # Create a VTK PolyData object
    polydata = vtk.vtkPolyData()
    points = vtk.vtkPoints()
    cells = vtk.vtkCellArray()

    # Add points to the polydata
    for vert in verts:
        points.InsertNextPoint(*vert)  # Unpack (x, y, z)
    polydata.SetPoints(points)

    # Add faces to the polydata
    for face in faces:
        triangle = vtk.vtkTriangle()
        for i in range(3):
            triangle.GetPointIds().SetId(i, face[i])
        cells.InsertNextCell(triangle)
    polydata.SetPolys(cells)


    # Write the transformed mesh to a VTK file
    writer = vtk.vtkPolyDataWriter()
    writer.SetFileName(output_filename)
    #writer.SetInputData(polydata_transformed)
    writer.SetInputData(polydata)
    writer.Write()

    print(f"Mesh saved to {output_filename}")


def save_labelmap_as_mha(numpy_array, metadata, output_filename):

    # Ensure the array is of integer type (label map)
    numpy_array = numpy_array.astype(np.uint8)

    # Convert to a SimpleITK image
    sitk_image = sitk.GetImageFromArray(numpy_array)

    spacing = metadata["spacing"]
    direction = metadata["direction"]
    origin = metadata["origin"]

    # Set metadata
    sitk_image.SetSpacing(spacing)
    sitk_image.SetOrigin(origin)
    sitk_image.SetDirection(direction)

    # Save the file
    sitk.WriteImage(sitk_image, output_filename)

    print('LabelMap .mha saved')



def process_directory(input_fluid_mha_dir, input_colon_mha_dir, output_fluid_mesh_dir, output_fluid_mha_dir, max_files=3):
    """
    Process a limited number of .mha files in a directory: clean the fluid segmentation and save them as .vtk mesh files and .mha segmentation file

    Parameters:
        input_fluid_mha_dir (str): Directory containing fluid .mha files.
        input_colon_mha_dir (str): Directory containing colon (air-fileld segments) .mha files.
        output_fluid_vtk_dir (str): Directory to save the VTK files.
        max_files (int): Maximum number of .mha files to process.

    """
    file_count = 0
    for root, _, files in os.walk(input_fluid_mha_dir):
        for file in files:
            if file.endswith(".mha"):
                if file_count >= max_files:
                    print(f"Reached the maximum limit of {max_files} files.")
                    return
                input_fluid_mha_file_path = os.path.join(root, file)
                print(f"Processing file: {input_fluid_mha_file_path}")

                # Get the input colon file name
                input_colon_filename = re.match(r"(.*colon_\d{3})", file)

                if input_colon_filename:
                    input_colon_mha_file_path = os.path.join(input_colon_mha_dir, f"{input_colon_filename.group(1)}.mha") 

                else:
                    raise ValueError("Filename format is not as expected")
                
                # Generate output .vtk and .mha file name
                output_fluid_mesh_path_2=os.path.join(output_fluid_mesh_dir, os.path.basename(input_fluid_mha_file_path).replace(".mha", "_cleaned_attached.vtk"))            
                output_fluid_mha_path=os.path.join(output_fluid_mha_dir, os.path.basename(input_fluid_mha_file_path).replace(".mha", "_cleaned_attached.mha"))

                #Post-process the fluid segmentation: clean the non-fluid segments, apply smoothing and connects the fluid with the air-filled parts. it returns numpy arrays alligned to RAI refernce system.
                if not os.path.exists(output_fluid_mha_path):
                    fluid_array_smooth, fluid_attached_to_colon, metadata = clean_fluid_segmentation(input_colon_mha_file_path, input_fluid_mha_file_path)
                

                    if np.max(fluid_array_smooth) > 0:
                        fluid_array_smooth = (fluid_array_smooth > 0).astype(np.uint8)
                        fluid_attached_to_colon= (fluid_attached_to_colon > 0).astype(np.uint8)
                        
                        direction = metadata["direction"]

                        #Re-orient colon to restore the original reference system
                        fluid_attached_to_colon_reverted= revert_reorientation(fluid_attached_to_colon, direction)
                        fluid_attached_to_colon_reverted_transposed = np.transpose(fluid_attached_to_colon_reverted, (2, 1, 0))
                
                        save_labelmap_as_mha(fluid_attached_to_colon_reverted, metadata, output_fluid_mha_path)

                        create_RAI_mesh(fluid_attached_to_colon_reverted_transposed, metadata, output_fluid_mesh_path_2)

                        
 #Process directory                      
input_colon_mha_dir = "/home/martina/repos/WP-BIO/model/nnunet/nnunet_raw/Dataset002_regiongrowing_qc_masked/labelsTs"  # Path to the colon binary mask directory
input_fluid_mha_dir = "/home/martina/Dataset/rootpainter_inference_mask_mha/TestSet"  # Path to the fluid pockets binary mask directory
output_fluid_mha_dir = "/home/martina/Dataset/rootpainter_inference_mask_mha/modified_testSet/"  # Path to save the updated fluid pockets mask
output_fluid_mesh_dir = "/home/martina/Dataset/rootpainter_inference_mask_mesh/TestSet/"  # Path to save the VTK file
process_directory(input_fluid_mha_dir, input_colon_mha_dir, output_fluid_mesh_dir, output_fluid_mha_dir, max_files=145)



